\chapter{Design and Implementation}
\label{ch:design_implementation}

This chapter outlines the design choices and technical implementation of the delegation mechanisms introduced into the vodle platform. Each section corresponds to a key objective defined in the previous chapter, detailing how it was approached within the constraints of vodle's architecture and data model.

\section{System Architecture Overview}
Vodle is built as a serverless web application that emphasises accessibility, client-side performance, and ease of deployment. Its architecture comprises two components:

\begin{itemize}
  \item \textbf{Frontend:} Implemented using Angular and the Ionic framework, the frontend provides a responsive and modular interface that works across both desktop and mobile devices. The use of Angular facilitates the creation of component-based user interfaces, essential for introducing interactive features such as the ranked delegation UI and vote splitting sliders.
  \item \textbf{Backend:} Vodle uses CouchDB as its database. There is no custom backend logic or middleware; instead, the application communicates directly with CouchDB over HTTP. All documents, including user ratings and delegation structures, are stored in JSON format.
  \item \textbf{Implications of a serverless architecture:}
  \begin{itemize}
    \item All vote delegation logic, including transitive resolution, cycle detection, and vote splitting calculations, must be executed in the browser. This places constraints on performance and requires careful optimisation of algorithms used.
    \item The lack of a traditional server-side backend limits opportunities for centralised verification or caching, increasing the complexity of handling dynamic delegation graphs client-side.
    \item Data structures must be serialised and de-serialised as JSON, requiring careful schema design to ensure backwards compatibility and clarity across different types of delegations.
  \end{itemize}
\end{itemize}

\section{Implement a Core Delegation Model into Vodle}

The core delegation mechanism was expanded into a fully operational system with support for delegation invitations, revocation, transitive resolution, and cycle detection.

\subsubsection{Delegation Interaction Flow}

A user initiates a delegation by selecting a delegate and sending them a unique link tied to a specific poll. When the recipient accepts the invitation, they gain permission to submit a vote on the user's behalf.

Delegated users can use their own vote for any option by using a toggle. For untoggled options, the vote is taken from their direct delegate by querying the database for the delegate's vote. Transitive delegation is automatically resolved by following the chain until a casting voter is found.

% egin{figure}[H]
% \centering
% %\includegraphics[width=0.9\linewidth]{../common/delegation\_flow\_diagram.png}
% \caption{Overview of user-delegation interaction in vodle.}
% \label{fig:delegation-architecture}
% \end{figure}

\subsubsection{Issues Identified}

Before the redesign, several critical issues were identified in the core delegation logic:

\begin{itemize}
    \item \textbf{No enforcement of cycle prevention:} It was possible for users to create cyclic delegations, leading to resolution loops.
    \item \textbf{Inconsistent UI feedback:} Delegated users were not correctly informed about how many others they were representing.
\end{itemize}

\subsubsection{Fixes and Enhancements}
To address these problems, several key fixes were implemented:

\begin{itemize}
    \item \textbf{Consistent cycle checking:} The system now uses an \texttt{inverse\_indirect\_map} to maintain a live view of indirect delegations. When a user clicks a delegation link, the sender's ID is checked against this map to detect cycles before they are committed.
    \item \textbf{UI accuracy improvements:} The interface now consistently displays ``your vote is used for \textit{n} other people'' using the inverse map to track vote reach in real time.
\end{itemize}

\subsubsection{Cycle Detection}
Cycle detection uses the \texttt{inverse\_indirect\_map}, where each key is a user ID and the value is a list of users who have delegated to them, either directly or indirectly.

\begin{itemize}
    \item When a user clicks on a delegation link, the system checks if the sender of the link is already in the accepting user's indirect delegator list.
    \item If so, a cycle would be formed, and the delegation is rejected.
    \item Upon acceptance, the inverse map is updated by appending the sender's delegators to the recipient's list. This updated value is stored and serialised in the database.
    \item When a delegation is revoked, the inverse map is also updated to remove the affected paths.
\end{itemize}

This approach allows for constant-time checks when handling delegation actions and scales efficiently with the number of users.

\subsubsection{Challenges}
Implementing consistent, real-time cycle detection using a fully client-side model was particularly challenging. Ensuring that the inverse map remained accurate and efficiently serialised under all scenarios---such as nested revocations or reassignments---required careful handling of delegation state. Additionally, updating the user interface to reflect the latest delegation status based on map values added further complexity.

\subsubsection{Outcome}
The revised implementation fully satisfies the core functional requirements for delegation, including user control, transitive resolution, and privacy-preserving representation.

\section{Implement Ranked Delegation into Vodle}
This feature introduced ranked delegation using the MinSum rule, allowing users to list fallback delegates in case their primary choice was unavailable.

\begin{itemize}
  \item UI for setting delegate rankings
  \item Explanation and application of the MinSum rule
  \item Implementation of ranked path resolution
  \item Illustrations and code snippets
\end{itemize}

\subsubsection{Challenges}
The MinSum rule had to be implemented efficiently using only browser-based resources. Ranking resolution had to preserve user intent while avoiding delegation ambiguity. Providing visual feedback to help users understand how rankings would resolve added an additional layer of design complexity.

\section{Implement a Vote Splitting Delegation Mechanism into Vodle}
Vote splitting was implemented to allow users to distribute fractional influence to multiple delegates.

\begin{itemize}
  \item UI for assigning weights
  \item Computation of weighted vote outcomes
  \item Constraints:
  \begin{itemize}
    \item Weight sum limit (\texttt{< 1.0})
    \item Error handling
  \end{itemize}
  \item Algorithm integration and frontend testing
\end{itemize}

\subsubsection{Challenges}
The vote splitting logic needed to maintain consistency with the MaxParC aggregation model, while ensuring intuitive user experience. Edge cases (e.g., partially overlapping delegate chains or missing data) introduced complexity during testing. Rendering weight distributions clearly in the UI while keeping the interface lightweight was a recurring challenge.

\section{Implement the Ability to Delegate Individual Options to Different Users}
This feature enabled per-option delegation, allowing users to assign a different delegate for each item in a poll.

\begin{itemize}
  \item Per-option delegate selection interface
  \item Independent resolution of each delegated option
  \item Storage schema modifications
\end{itemize}

\subsubsection{Challenges}
This mechanism required updates to the internal delegation logic to handle resolution at the option level. The user interface also had to be adapted to display multiple concurrent delegate selections without overwhelming the user. Debugging resolution logic for hybrid delegation modes (e.g., one direct, one split, one ranked) was non-trivial.

\section{Simulate Delegation Mechanisms}
The simulation objective was de-scoped due to time constraints and prioritisation of implementation work. While initial planning and framework selection (Mesa) were completed, no functional simulation code was delivered. The decision to drop this extension is discussed further in the Project Management chapter.

\section{Design Decisions and Trade-offs}
\begin{itemize}
  \item All logic had to run client-side due to the serverless CouchDB architecture, limiting complexity and computational resources.
  \item A consistent JSON format was required for all data models, impacting flexibility in data design.
  \item Trade-offs were made between expressive delegation types and usability, particularly in the option-specific and vote splitting interfaces.
\end{itemize}

\section{Summary}
\begin{itemize}
  \item Each objective was successfully implemented within the constraints of the vodle platform.
  \item Challenges were primarily technical (client-side performance, real-time resolution) and design-oriented (clarity and control for users).
  \item The final implementation offers a modular, extensible delegation system that addresses the key theoretical and practical limitations outlined in earlier chapters.
\end{itemize}

