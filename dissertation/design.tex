\chapter{Design and Implementation}
\label{ch:design_implementation}

This chapter outlines the design choices and technical implementation of the delegation mechanisms introduced into the vodle platform. Each section corresponds to a key objective defined in the previous chapter, detailing how it was approached within the constraints of vodle's architecture and data model. These approaches are informed directly by the findings presented in Chapter~\ref{ch:background}, which highlighted key weaknesses in traditional liquid democracy systems and surveyed alternative mechanisms with practical benefits.

\section{System Architecture Overview}
Vodle is built as a serverless web application that emphasises accessibility, client-side performance, and ease of deployment. Its architecture comprises three main components:

\begin{itemize}
  \item \textbf{Frontend:} Implemented using Angular and the Ionic framework, the frontend provides a responsive and modular interface that works across both desktop and mobile devices. The use of Angular facilitates the creation of component-based user interfaces, essential for introducing interactive features such as the ranked delegation UI and vote splitting sliders.
  \item \textbf{Backend:} Vodle uses CouchDB as its database. There is no custom backend logic or middleware; instead, the application communicates directly with CouchDB over HTTP. All documents, including user ratings and delegation structures, are stored in JSON format.
  \item \textbf{Implications of a serverless architecture:}
  \begin{itemize}
    \item All vote delegation logic, including transitive resolution, cycle detection, and vote splitting calculations, must be executed in the browser. This places constraints on performance and requires careful optimisation of algorithms used.
    \item The lack of a traditional server-side backend limits opportunities for centralised verification or caching, increasing the complexity of handling dynamic delegation graphs client-side.
    \item Data structures must be serialised and de-serialised as JSON, requiring careful schema design to ensure backwards compatibility and clarity across different types of delegations.
  \end{itemize}
  \item \textbf{Interaction Flow:} A user-delegation interaction begins when a user initiates a delegation, shares a link, and their selected delegate accepts it. From that point, the delegate can act on behalf of the original user. The logic for resolving delegation chains and calculating final vote weights occurs whenever a delegation is accepted or modified.
\end{itemize}

\begin{figure}[H]
  \centering
  %\includegraphics[width=0.9\linewidth]{../common/delegation_flow_diagram.png}
  \caption{Overview of user-delegation interaction in vodle.}
  \label{fig:delegation-architecture}
\end{figure}

\section{Data Model Design}
\begin{itemize}
  \item Overview of how delegation data is structured in CouchDB
  \item Storage format for different delegation types:
  \begin{itemize}
    \item Core
    \item Ranked
    \item Vote splitting
    \item Option-specific
  \end{itemize}
  \item JSON examples for each data format
  \item Discussion of schema compatibility and serialisation
\end{itemize}

\section{Core Delegation Model}
\begin{itemize}
  \item Description of the existing implementation and its limitations
  \item Improvements made:
  \begin{itemize}
    \item Invitation and acceptance logic
    \item Transitive delegation
    \item Cycle detection enhancements (motivated by issues outlined in Section~2.1.1 of Chapter~\ref{ch:background})
  \end{itemize}
  \item Code snippets and UI screenshots
\end{itemize}

\section{Ranked Delegation}
\begin{itemize}
  \item Description of the UI for setting delegate rankings
  \item Explanation of the MinSum algorithm and why it was selected
  \item Implementation of ranked delegation path resolution
  \item Graphical illustrations and code snippets
\end{itemize}

This feature directly addresses the issue of vote loss due to unavailable delegates, as described in Chapter~\ref{ch:background}. Ranked delegation ensures fallback options are available, reducing the likelihood of vote loss due to abstention or cycle involvement.

\section{Vote Splitting Delegation}
\begin{itemize}
  \item UI design for assigning weights to multiple delegates
  \item Computation of final ratings from weighted delegations
  \item Constraints:
  \begin{itemize}
    \item Total weight limit
    \item Error handling
  \end{itemize}
  \item Algorithm integration and testing
\end{itemize}

Vote splitting provides a mechanism to mitigate the influence of super-voters (Chapter~\ref{ch:background}, Section~2.1.3), by enabling distributed influence rather than concentrating votes in a single delegate.

\section{Option-Specific Delegation}
\begin{itemize}
  \item Interface design for assigning delegates per option
  \item Justification from background research (e.g. category-specific delegation in Google Votes)
  \item Implementation of independent resolution per option
  \item Data structure considerations
\end{itemize}

Inspired by the design of Google Votes (Chapter~\ref{ch:background}), this feature improves expressiveness and relevance in delegation by aligning delegation choices with topic-specific expertise.

\section{Simulation Engine}
Although agent-based modelling (ABM) was initially proposed as a method for validating delegation mechanisms in dynamic contexts (see Chapter~\ref{ch:background}), it was not implemented due to time constraints. This decision and its implications will be discussed further in the Project Management chapter.

\section{Integration and Testing}
\begin{itemize}
  \item Testing approach:
  \begin{itemize}
    \item Unit testing
    \item Integration testing
    \item UI testing
  \end{itemize}
  \item Use of Angular testing tools (Jasmine, Karma)
  \item Git branching strategy and development workflow
\end{itemize}

\section{Design Decisions and Trade-offs}
\begin{itemize}
  \item Handling client-side complexity
  \item Delegation resolution performance
  \item Usability vs. expressiveness in the UI
\end{itemize}

\section{Summary}
\begin{itemize}
  \item Recap of design challenges and how they were addressed
  \item How implementation choices align with the core project goals and constraints, as well as solutions identified through background research
\end{itemize}

