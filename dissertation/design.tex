\chapter{Design and Implementation}
\label{ch:design_implementation}
This chapter describes the design and implementation of the delegation mechanisms integrated into vodle, detailing both the technical approach and practical decisions made throughout development. It begins by outlining vodle's existing system architecture, clarifying how this influenced the integration of new delegation features. 

Each subsequent section aligns directly with one of the project objectives defined previously, explaining the rationale behind key design choices, algorithms, and interface elements. Emphasis is placed on the critical design trade-offs and challenges encountered, highlighting how constraints such as the serverless architecture and client-side computation informed implementation decisions.

\section{System Architecture Overview}
Vodle is built as a serverless web application that emphasises accessibility, client-side performance, and ease of deployment. Its architecture comprises two components:

\begin{enumerate}
  \item \textbf{Frontend:} Implemented using Angular and the Ionic framework, the frontend provides a responsive and modular interface that works across both desktop and mobile devices. The use of Angular facilitates the creation of component-based user interfaces, essential for introducing interactive features such as the ranked delegation UI and vote splitting sliders.
  \item \textbf{Backend:} Vodle uses CouchDB as its database. There is no custom backend logic or middleware; instead, the frontend application communicates directly with CouchDB over HTTP.
\end{enumerate}

\subsubsection{Implications of This Architecture}
Vodle's serverless architecture has several implications for the design and implementation of the delegation mechanisms, especially due to the absence of a traditional data processing backend. The following points summarise the key considerations:
\begin{itemize}
  \item All vote delegation logic, including transitive resolution, cycle detection, and vote splitting calculations, must be executed in the browser. This places constraints on performance and requires careful optimisation of algorithms used.
  \item CouchDB's document-based storage model means that all data must be serialised and deserialised in JSON format. This affects how data structures are designed and manipulated, as well as how they are stored and retrieved from the database.
\end{itemize}

\subsection{CouchDB Configuration}
% Each used remote CouchDB is identified by the URL of a CouchDB server (!) 
% (rather than the URL of a database contained in that server!).
% The CouchDB server must provide:
% - a user database named '_users' (which is the standard name for user databases)
% - a database named 'vodle' that will contain the data
% - a user named 'vodle' that has write access to both (!) these databases.
% 
% The user 'vodle' will be used by the vodle app to automatically create the other database users
% ('vodle.user.UUU', 'vodle.poll.PPP', and 'vodle.poll.PPP.voter.VVV')
% when a user logs in the first time, changes their password, creates a new poll, 
% or starts participating in a poll as a voter.
% This way the database administrator only needs to be involved when setting up the database initially,
% but not later on to create users.
% 
% Although the database user 'vodle' can create users, it cannot delete or modify users or read their passwords.
% Also, neither the database user 'vodle' or 'vodle.poll.PPP' can change their own password.
% This way, no-one can delete or overtake the database users 'vodle.user.UUU' or 'vodle.poll.PPP.voter.VVV'
% of any other person or prevent others from accessing their personal, poll, or voter data.

\section{Implement a Core Delegation Model into vodle}
\label{sec:core_delegation_detailed}

This section provides a self-contained, technical narrative of how the core delegation mechanism was conceived, which problems it solved, and how the final client-side implementation works. It follows the structure below so that each stage (from user interaction to data consistency) can be expanded or shortened independently during editing.

\subsection{Delegation Interaction Flow}
Figure~\ref{fig:delegation-flow} depicts the life-cycle of a delegation. The diagram is intentionally simple--only the four message exchanges required to set up or tear down a delegation are shown--so the reader can map each arrow to a concrete API call or UI control.

% ------------- DIAGRAM PLACEHOLDER -------------
% Replace the TikZ skeleton with an exported SVG once finalised.
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[node distance=3cm,>=stealth,thick]
    % clients
    \node[rectangle,draw,rounded corners,fill=gray!5] (A) {Delegator A};
    \node[rectangle,draw,rounded corners,fill=gray!5,right of=A] (B) {Delegate B};
    % arrows
    \draw[->] (A) -- node[above]{share link} (B);
    \draw[->,dashed] (B) .. controls +(0,1.5) and +(0,1.5) .. node[above]{accept} (A);
    \draw[->] (B.south) -- ++(0,-1.2) node[midway,right]{casts vote};
    \draw[->] (A.south) -- ++(0,-1.2) node[midway,left]{tally uses B};
  \end{tikzpicture}
  \caption{Minimal message sequence for creating a delegation. Only four interactions are required: (1) A shares a link, (2) B accepts, (3) B may cast or delegate further, (4) A's vote resolves through B.}
  \label{fig:delegation-flow}
\end{figure}

At runtime the app must therefore support:
\begin{enumerate}
  \item Generating and copying a poll-scoped, user-scoped invitation link.
  \item Polling CouchDB for acceptance (or rejection) of that link.
  \item A client-side resolution routine that follows the chain of \texttt{delegateFor} relationships until a casting voter is found.
  \item Revocation that is immediate yet conflict-free if multiple clients are open.
\end{enumerate}

\subsection{Issues Prior to Redesign - TODO}
The original implementation of liquid democracy in vodle functions as a proof-of-concept, but it has several limitations that hinder its usability and reliability. The following sections outline some of the key issues that were identified whilst planning the redesign.

\textbf{Inconsistency in data between clients} delegation graph not synched -- leads to cycle checking issue \dots

\paragraph{Out-of-sync state} Each browser session cached its own copy of the delegation graph; no push notifications existed to bring other clients up-to-date.
\paragraph{Inconsistent cycle checking} Because state diverged, the local "no-loop" tests sometimes produced different answers on different machines.
\paragraph{UI drift} Controls such as ``delegate none/some/all'' and the ``your vote is used for \(n\) others'' badge used stale data and became misleading.

\subsection{Cycle Checking}
Robust cycle detection is a core requirement for any system implementing transitive delegation. In liquid democracy, cycles render votes unresolved and potentially lost, directly undermining the integrity of the outcome. Given vodle's dynamic and client-driven architecture, it was crucial to implement an efficient, client-side mechanism that could detect and prevent cycles in real time, without requiring server-side intervention or excessive computation.

The original implementation of cycle prevention in vodle was incomplete and inconsistently enforced. Because delegation data was locally cached and not always synchronised across clients, users could unknowingly create cycles that would only be caught (or missed) depending on the state of their browser session. This led to erratic user experiences, where a delegation might succeed on one device but be rejected on another.

The redesigned cycle checking approach addresses this inconsistency through the introduction of a shared data structure, stored in CouchDB and updated collaboratively by all clients. This ensures consistent validation of new delegations and enables immediate feedback to users attempting to create an invalid delegation path. The remainder of this section details the algorithmic choices, data structures, and UI modifications used to implement reliable cycle detection in vodle.

\subsubsection{Algorithm Design}
The current delegations in a system can be represented as a directed graph where each user is represented as a node and each delegation is represented as a directed edge $(u,v)$, where $u$ is the delegator and $v$ is the delegate. The goal of the cycle-checking algorithm is to ensure that a proposed delegation does not create a cycle in this directed graph.

A new delegation $X\to Y$ is valid if and only if $Y$ is \emph{not} reachable from $X$ in that DAG -- if $Y$ is not a descendant of $X$.

Instead of checking for this condition directly using a depth-first search (DFS) or breadth-first search (BFS), a more efficient approach is to maintain a list of all descendants for each user. This allows us to check if $Y$ is in the list of descendants of $X$ in constant time. The implementation of this algorithm is detailed in the next section.

\subsubsection{Implementation Details}
A hashmap is used to store the descendants of each user. The keys are user IDs, and the values are sets of user IDs representing the direct delegates of that user. In the code, this hashmap is referred to as ``\verb|inverse_indirect_map|''.
\begin{figure}[H]
  \centering
  \begin{minted}{json}
    "inverse_indirect_map": {
      "B": ["A"],
      "C": ["B", "A"],
      "D": ["C", "B", "A"]
    }
  \end{minted}
  \caption{Example of a hashmap for users A, B, C, and D. User A has delegated to B, user B has delegated to C, and user C has delegated to D. Consequently, the descendants of user D are A, B and C.}
  \label{fig:inverse_indirect_map}
\end{figure}

This map enables several key operations required for maintaining a consistent and cycle-free delegation graph:

\begin{itemize}
  \item \textbf{Check Delegation Validity:} To determine whether a delegation \(X \!\to\! Y\) would create a cycle, the system checks if \(Y\) already appears in the set of descendants of \(X\). If so, the new delegation is invalid. This check takes \(O(1)\) time.
  \begin{figure}[H]
    \centering
    \begin{minted}{javascript}
      const inverse_indirect_map = this.G.D.get_inverse_indirect_map(pid);
      const descendant_set = inverse_indirect_map.get(delegate_vid);
      if (descendant_set.has(myvid)) {
        cycle = true;
      }
    \end{minted}
    \caption{Code for checking if a delegation is valid. This check is triggered when a user clicks on a delegate link. The map is retrieved from the synchronised local cache, and the set of descendants is used to confirm that a cycle would not be formed.}
  \end{figure}

  \item \textbf{Add Delegation Edge:} When a new delegation \(X \to Y\) is accepted, the system must ensure that the descendant relationship is updated consistently. Specifically, for $Y$ and every user \(u\) such that \(Y \in \texttt{desc}(u)\), their descendants must be updated to include both \(X\) and all of \(X\)'s current descendants.

  \item \textbf{Remove Delegation Edge:} When a delegation \(X \!\to\! Y\) is removed, the system must ensure that the descendant relationship is updated consistently. Specifically, for $Y$ and every user \(u\) such that \(Y \in \texttt{desc}(u)\), their descendants must be updated to remove both \(X\) and all of \(X\)'s current descendants.
\end{itemize}

\subsubsection{Synchronisation -- TODO}
Explain CouchDB problem with poll db and user db. Every user needs to be able to fetch and push \verb|inverse_indirect_map|.

\subsubsection{Practical Challenges -- TODO}

\subsection{User Interface Changes -- TODO}
\begin{itemize}
  \item Re-bound the ``delegate none/some/all'' switch so it toggles \emph{only} the current option and refreshes its label after server confirmation.
  \item Re-implemented the ``vote is used for \(n\) others'' badge so it recomputes from the latest \texttt{inverse\_indirect\_map} rather than client guesses.
  \item Added unobtrusive toast notifications when a delegation request is rejected (e.g.\ cycle detected) so the user can immediately choose another delegate.
\end{itemize}

\subsection{Summary -- TODO}


\section{Implement Ranked Delegation into Vodle}
This feature introduced ranked delegation using the MinSum rule, allowing users to list fallback delegates in case their primary choice was unavailable.

\begin{itemize}
  \item UI for setting delegate rankings
  \item New UI when making a poll to allow user to select ranked delegation.
  \item \verb|direct_delegation_map|: maps user IDs to list of ranked delegates [[delegationid, rank, status]...]
  \item Explanation and application of the MinSum rule
  \item How do we determine who is a casting voter?
  \item Implementation of ranked path resolution
  \item Illustrations and code snippets
\end{itemize}

\subsubsection{Challenges}
The MinSum rule had to be implemented efficiently using only browser-based resources. Ranking resolution had to preserve user intent while avoiding delegation ambiguity. Providing visual feedback to help users understand how rankings would resolve added an additional layer of design complexity.

\section{Implement a Vote Splitting Delegation Mechanism into Vodle}
Vote splitting was implemented to allow users to distribute fractional influence to multiple delegates.

\begin{itemize}
  \item UI for assigning weights
  \item modify\verb|direct_delegation_map|to include weights [[delegationid, weight, status]...]
  \item Computation of weighted vote outcomes
  \item Constraints:
  \begin{itemize}
    \item Weight sum limit (\texttt{< 1.0})
    \item Error handling
  \end{itemize}
  \item Optimisations to limit database writes.
  \item Algorithm integration and frontend testing
\end{itemize}

\subsubsection{Challenges}
The vote splitting logic needed to maintain consistency with the MaxParC aggregation model, while ensuring intuitive user experience. Edge cases (e.g., partially overlapping delegate chains or missing data) introduced complexity during testing. Rendering weight distributions clearly in the UI while keeping the interface lightweight was a recurring challenge.

\section{Implement the Ability to Delegate Individual Options to Different Users}
This feature enabled per-option delegation, allowing users to assign a different delegate for each item in a poll.

\begin{itemize}
  \item Per-option delegate selection interface
  \item Independent resolution of each delegated option
  \item talk about nested map - need to take care to serialise.
  \item \verb|direct_delegation_map|: \verb|option_id| -> \verb|user_id| -> [delegationid, null, status]
  \item \verb|inverse_indirect_map|: \verb|option_id| -> \verb|user_id| -> list of users who have delegated to them, either directly or indirectly.
  \item Storage schema modifications
\end{itemize}

\subsubsection{Challenges}
This mechanism required updates to the internal delegation logic to handle resolution at the option level. The user interface also had to be adapted to display multiple concurrent delegate selections without overwhelming the user. Debugging resolution logic for hybrid delegation modes (e.g., one direct, one split, one ranked) was non-trivial.

\section{Simulate Delegation Mechanisms}
The simulation objective was de-scoped due to time constraints and prioritisation of implementation work. While initial planning and framework selection (Mesa) were completed, no functional simulation code was delivered. The decision to drop this extension is discussed further in the Project Management chapter.

\section{Design Decisions and Trade-offs}
\begin{itemize}
  \item All logic had to run client-side due to the serverless CouchDB architecture, limiting complexity and computational resources.
  \item A consistent JSON format was required for all data models, impacting flexibility in data design.
  \item Trade-offs were made between expressive delegation types and usability, particularly in the option-specific and vote splitting interfaces.
\end{itemize}

\section{Summary}
\begin{itemize}
  \item Each objective was successfully implemented within the constraints of the vodle platform.
  \item Challenges were primarily technical (client-side performance, real-time resolution) and design-oriented (clarity and control for users).
  \item The final implementation offers a modular, extensible delegation system that addresses the key theoretical and practical limitations outlined in earlier chapters.
\end{itemize}

